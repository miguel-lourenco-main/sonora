/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as errors from "../models/errors/index.js";
import * as operations from "../models/operations/index.js";
import { isBlobLike } from "../types/blobs.js";
import * as z from "zod";

export class Edgen extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Files List
     *
     * @remarks
     * List session files recursively
     */
    async filesListFilesSessionIdGet(
        request: operations.FilesListFilesSessionIdGetRequest,
        options?: RequestOptions
    ): Promise<Array<string>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FilesListFilesSessionIdGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            session_id: encodeSimple$("session_id", payload$.session_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/files/{session_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "files_list_files__session_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<string>>()
            .json(200, z.array(z.string()))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Files Upload
     *
     * @remarks
     * Upload a file
     */
    async filesUploadFilesSessionIdPost(
        request: operations.FilesUploadFilesSessionIdPostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.FilesUploadFilesSessionIdPostRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (isBlobLike(payload$.Body_files_upload_files__session_id__post.file)) {
            body$.append("file", payload$.Body_files_upload_files__session_id__post.file);
        } else {
            body$.append(
                "file",
                new Blob([payload$.Body_files_upload_files__session_id__post.file.content], {
                    type: "application/octet-stream",
                }),
                payload$.Body_files_upload_files__session_id__post.file.fileName
            );
        }

        const pathParams$ = {
            session_id: encodeSimple$("session_id", payload$.session_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/files/{session_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "files_upload_files__session_id__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Files Retrieve
     *
     * @remarks
     * Retrieve a file, given its path
     */
    async filesRetrieveFilesSessionIdFilePathGet(
        request: operations.FilesRetrieveFilesSessionIdFilePathGetRequest,
        options?: RequestOptions
    ): Promise<void> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.FilesRetrieveFilesSessionIdFilePathGetRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            file_path: encodeSimple$("file_path", payload$.file_path, {
                explode: false,
                charEncoding: "percent",
            }),
            session_id: encodeSimple$("session_id", payload$.session_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/files/{session_id}/{file_path}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "files_retrieve_files__session_id___file_path__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<void>()
            .void(200, z.void())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Upload Local File
     *
     * @remarks
     * Upload a local file
     */
    async uploadLocalFileLocalfilePost(
        request: components.BodyUploadLocalFileLocalfilePost,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.BodyUploadLocalFileLocalfilePost$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (isBlobLike(payload$.file)) {
            body$.append("file", payload$.file);
        } else {
            body$.append(
                "file",
                new Blob([payload$.file.content], { type: "application/octet-stream" }),
                payload$.file.fileName
            );
        }

        const path$ = this.templateURLComponent("/localfile")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "upload_local_file_localfile_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Connectors
     *
     * @remarks
     * List all connectors for a user
     */
    async listConnectorsConnectorsGet(
        options?: RequestOptions
    ): Promise<Array<components.Connector>> {
        const path$ = this.templateURLComponent("/connectors")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_connectors_connectors_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.Connector>>()
            .json(200, z.array(components.Connector$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Connector
     *
     * @remarks
     * Create a new connector
     */
    async createConnectorConnectorsPost(
        request: components.ConnectorCreate,
        options?: RequestOptions
    ): Promise<components.Connector> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.ConnectorCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/connectors")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_connector_connectors_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.Connector>()
            .json(200, components.Connector$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Connector
     *
     * @remarks
     * Delete a connector
     */
    async deleteConnectorConnectorsDeleteDelete(
        request: operations.DeleteConnectorConnectorsDeleteDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteConnectorConnectorsDeleteDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/connectors/delete")();

        const query$ = encodeFormQuery$({
            connector_id: payload$.connector_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_connector_connectors_delete_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Knowledge Bases
     *
     * @remarks
     * List all knowledge bases for a user
     */
    async listKnowledgeBasesKnowledgeBasesGet(
        options?: RequestOptions
    ): Promise<Array<components.KnowledgeBase>> {
        const path$ = this.templateURLComponent("/knowledge_bases")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_knowledge_bases_knowledge_bases_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.KnowledgeBase>>()
            .json(200, z.array(components.KnowledgeBase$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Knowledge Base
     *
     * @remarks
     * Create a new knowledge base
     */
    async createKnowledgeBaseKnowledgeBasesPost(
        request: components.KnowledgeBaseCreate,
        options?: RequestOptions
    ): Promise<components.KnowledgeBase> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.KnowledgeBaseCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/knowledge_bases")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_knowledge_base_knowledge_bases_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.KnowledgeBase>()
            .json(200, components.KnowledgeBase$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Knowledge Base
     *
     * @remarks
     * Delete a knowledge base
     */
    async deleteKnowledgeBaseKnowledgeBasesDeleteDelete(
        request: operations.DeleteKnowledgeBaseKnowledgeBasesDeleteDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteKnowledgeBaseKnowledgeBasesDeleteDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/knowledge_bases/delete")();

        const query$ = encodeFormQuery$({
            knowledge_base_id: payload$.knowledge_base_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_knowledge_base_knowledge_bases_delete_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Link Knowledge Base Connector
     *
     * @remarks
     * Link a connector to a knowledge base
     */
    async linkKnowledgeBaseConnectorKnowledgeBasesLinkConnectorKnowledgeBaseIdConnectorIdPost(
        request: operations.LinkKnowledgeBaseConnectorKnowledgeBasesLinkConnectorKnowledgeBaseIdConnectorIdPostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.LinkKnowledgeBaseConnectorKnowledgeBasesLinkConnectorKnowledgeBaseIdConnectorIdPostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connector_id: encodeSimple$("connector_id", payload$.connector_id, {
                explode: false,
                charEncoding: "percent",
            }),
            knowledge_base_id: encodeSimple$("knowledge_base_id", payload$.knowledge_base_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/knowledge_bases/link/connector/{knowledge_base_id}/{connector_id}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "link_knowledge_base_connector_knowledge_bases_link_connector__knowledge_base_id___connector_id__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Unlink Knowledge Base Connector
     *
     * @remarks
     * Unlink a connector from a knowledge base
     */
    async unlinkKnowledgeBaseConnectorKnowledgeBasesLinkConnectorKnowledgeBaseIdConnectorIdDelete(
        request: operations.UnlinkKnowledgeBaseConnectorKnowledgeBasesLinkConnectorKnowledgeBaseIdConnectorIdDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.UnlinkKnowledgeBaseConnectorKnowledgeBasesLinkConnectorKnowledgeBaseIdConnectorIdDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            connector_id: encodeSimple$("connector_id", payload$.connector_id, {
                explode: false,
                charEncoding: "percent",
            }),
            knowledge_base_id: encodeSimple$("knowledge_base_id", payload$.knowledge_base_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/knowledge_bases/link/connector/{knowledge_base_id}/{connector_id}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "unlink_knowledge_base_connector_knowledge_bases_link_connector__knowledge_base_id___connector_id__delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Knowledge Base Connectors
     *
     * @remarks
     * Get all connectors linked to a knowledge base
     */
    async getKnowledgeBaseConnectorsKnowledgeBasesLinkConnectorKnowledgeBaseIdGet(
        request: operations.GetKnowledgeBaseConnectorsKnowledgeBasesLinkConnectorKnowledgeBaseIdGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.Connector>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetKnowledgeBaseConnectorsKnowledgeBasesLinkConnectorKnowledgeBaseIdGetRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            knowledge_base_id: encodeSimple$("knowledge_base_id", payload$.knowledge_base_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/knowledge_bases/link/connector/{knowledge_base_id}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "get_knowledge_base_connectors_knowledge_bases_link_connector__knowledge_base_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.Connector>>()
            .json(200, z.array(components.Connector$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Skills
     *
     * @remarks
     * List all skills for a user
     */
    async listSkillsSkillsGet(options?: RequestOptions): Promise<Array<components.Skill>> {
        const path$ = this.templateURLComponent("/skills")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_skills_skills_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.Skill>>()
            .json(200, z.array(components.Skill$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Skill
     *
     * @remarks
     * Create a new skill
     */
    async createSkillSkillsPost(
        request: components.SkillCreate,
        options?: RequestOptions
    ): Promise<components.Skill> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.SkillCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/skills")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_skill_skills_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.Skill>()
            .json(200, components.Skill$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Skill
     *
     * @remarks
     * Delete a skill
     */
    async deleteSkillSkillsDeleteDelete(
        request: operations.DeleteSkillSkillsDeleteDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteSkillSkillsDeleteDeleteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/skills/delete")();

        const query$ = encodeFormQuery$({
            skill_id: payload$.skill_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_skill_skills_delete_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Models
     *
     * @remarks
     * List all models for a user
     */
    async listModelsModelsGet(options?: RequestOptions): Promise<Array<components.ModelOutput>> {
        const path$ = this.templateURLComponent("/models")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_models_models_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.ModelOutput>>()
            .json(200, z.array(components.ModelOutput$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Model
     *
     * @remarks
     * Create a new model
     */
    async createModelModelsPost(
        request: components.ModelCreate,
        options?: RequestOptions
    ): Promise<components.ModelOutput> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.ModelCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/models")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_model_models_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.ModelOutput>()
            .json(200, components.ModelOutput$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Test Model Endpoint
     *
     * @remarks
     * Test a model
     */
    async testModelEndpointModelsTestPost(
        request: components.ModelInput,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.ModelInput$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/models/test")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "test_model_endpoint_models_test_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Model
     *
     * @remarks
     * Delete a model
     */
    async deleteModelModelsDeleteDelete(
        request: operations.DeleteModelModelsDeleteDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteModelModelsDeleteDeleteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/models/delete")();

        const query$ = encodeFormQuery$({
            model_id: payload$.model_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_model_models_delete_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Agents
     *
     * @remarks
     * List all agents for a user
     */
    async listAgentsAgentsGet(options?: RequestOptions): Promise<Array<components.Agent>> {
        const path$ = this.templateURLComponent("/agents")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_agents_agents_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.Agent>>()
            .json(200, z.array(components.Agent$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Agent
     *
     * @remarks
     * Create a new agent
     */
    async createAgentAgentsPost(
        request: components.AgentCreate,
        options?: RequestOptions
    ): Promise<components.Agent> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.AgentCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/agents")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_agent_agents_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.Agent>()
            .json(200, components.Agent$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Agent
     *
     * @remarks
     * Delete an agent
     */
    async deleteAgentAgentsDeleteDelete(
        request: operations.DeleteAgentAgentsDeleteDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteAgentAgentsDeleteDeleteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/agents/delete")();

        const query$ = encodeFormQuery$({
            agent_id: payload$.agent_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_agent_agents_delete_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Link Agent Model
     *
     * @remarks
     * Link a model to an agent
     */
    async linkAgentModelAgentsLinkModelAgentIdModelIdPost(
        request: operations.LinkAgentModelAgentsLinkModelAgentIdModelIdPostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.LinkAgentModelAgentsLinkModelAgentIdModelIdPostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            model_id: encodeSimple$("model_id", payload$.model_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/model/{agent_id}/{model_id}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "link_agent_model_agents_link_model__agent_id___model_id__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Unlink Agent Model
     *
     * @remarks
     * Unlink a model from an agent
     */
    async unlinkAgentModelAgentsLinkModelAgentIdModelIdDelete(
        request: operations.UnlinkAgentModelAgentsLinkModelAgentIdModelIdDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.UnlinkAgentModelAgentsLinkModelAgentIdModelIdDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            model_id: encodeSimple$("model_id", payload$.model_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/model/{agent_id}/{model_id}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "unlink_agent_model_agents_link_model__agent_id___model_id__delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Agent Models
     *
     * @remarks
     * Get all models linked to an agent
     */
    async getAgentModelsAgentsLinkModelAgentIdGet(
        request: operations.GetAgentModelsAgentsLinkModelAgentIdGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.ModelOutput>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetAgentModelsAgentsLinkModelAgentIdGetRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/model/{agent_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_agent_models_agents_link_model__agent_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.ModelOutput>>()
            .json(200, z.array(components.ModelOutput$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Link Agent Skill
     *
     * @remarks
     * Link an a skill to an agent
     */
    async linkAgentSkillAgentsLinkSkillAgentIdSkillIdPost(
        request: operations.LinkAgentSkillAgentsLinkSkillAgentIdSkillIdPostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.LinkAgentSkillAgentsLinkSkillAgentIdSkillIdPostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            skill_id: encodeSimple$("skill_id", payload$.skill_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/skill/{agent_id}/{skill_id}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "link_agent_skill_agents_link_skill__agent_id___skill_id__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Unlink Agent Skill
     *
     * @remarks
     * Unlink an a skill from an agent
     */
    async unlinkAgentSkillAgentsLinkSkillAgentIdSkillIdDelete(
        request: operations.UnlinkAgentSkillAgentsLinkSkillAgentIdSkillIdDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.UnlinkAgentSkillAgentsLinkSkillAgentIdSkillIdDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            skill_id: encodeSimple$("skill_id", payload$.skill_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/skill/{agent_id}/{skill_id}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "unlink_agent_skill_agents_link_skill__agent_id___skill_id__delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Agent Skills
     *
     * @remarks
     * Get all skills linked to an agent
     */
    async getAgentSkillsAgentsLinkSkillAgentIdGet(
        request: operations.GetAgentSkillsAgentsLinkSkillAgentIdGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.Skill>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetAgentSkillsAgentsLinkSkillAgentIdGetRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/skill/{agent_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_agent_skills_agents_link_skill__agent_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.Skill>>()
            .json(200, z.array(components.Skill$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Link Agent Agent
     *
     * @remarks
     * Link an agent to another agent
     */
    async linkAgentAgentAgentsLinkAgentPrimaryAgentIdSecondaryAgentIdPost(
        request: operations.LinkAgentAgentAgentsLinkAgentPrimaryAgentIdSecondaryAgentIdPostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.LinkAgentAgentAgentsLinkAgentPrimaryAgentIdSecondaryAgentIdPostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            primary_agent_id: encodeSimple$("primary_agent_id", payload$.primary_agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            secondary_agent_id: encodeSimple$("secondary_agent_id", payload$.secondary_agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/agents/link/agent/{primary_agent_id}/{secondary_agent_id}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "link_agent_agent_agents_link_agent__primary_agent_id___secondary_agent_id__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Unlink Agent Agent
     *
     * @remarks
     * Unlink an agent from another agent
     */
    async unlinkAgentAgentAgentsLinkAgentPrimaryAgentIdSecondaryAgentIdDelete(
        request: operations.UnlinkAgentAgentAgentsLinkAgentPrimaryAgentIdSecondaryAgentIdDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.UnlinkAgentAgentAgentsLinkAgentPrimaryAgentIdSecondaryAgentIdDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            primary_agent_id: encodeSimple$("primary_agent_id", payload$.primary_agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            secondary_agent_id: encodeSimple$("secondary_agent_id", payload$.secondary_agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/agents/link/agent/{primary_agent_id}/{secondary_agent_id}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "unlink_agent_agent_agents_link_agent__primary_agent_id___secondary_agent_id__delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Linked Agents
     *
     * @remarks
     * Get all agents linked to an agent
     */
    async getLinkedAgentsAgentsLinkAgentAgentIdGet(
        request: operations.GetLinkedAgentsAgentsLinkAgentAgentIdGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.Agent>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetLinkedAgentsAgentsLinkAgentAgentIdGetRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/agent/{agent_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_linked_agents_agents_link_agent__agent_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.Agent>>()
            .json(200, z.array(components.Agent$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Link Agent Kb
     *
     * @remarks
     * Link a knowledge base to an agent
     */
    async linkAgentKbAgentsLinkKbAgentIdKbIdPost(
        request: operations.LinkAgentKbAgentsLinkKbAgentIdKbIdPostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.LinkAgentKbAgentsLinkKbAgentIdKbIdPostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            kb_id: encodeSimple$("kb_id", payload$.kb_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/kb/{agent_id}/{kb_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "link_agent_kb_agents_link_kb__agent_id___kb_id__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Unlink Agent Kb
     *
     * @remarks
     * Unlink a knowledge base from an agent
     */
    async unlinkAgentKbAgentsLinkKbAgentIdKbIdDelete(
        request: operations.UnlinkAgentKbAgentsLinkKbAgentIdKbIdDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.UnlinkAgentKbAgentsLinkKbAgentIdKbIdDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            kb_id: encodeSimple$("kb_id", payload$.kb_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/kb/{agent_id}/{kb_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "unlink_agent_kb_agents_link_kb__agent_id___kb_id__delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Agent Kbs
     *
     * @remarks
     * Get all knowledge bases linked to an agent
     */
    async getAgentKbsAgentsLinkKbAgentIdGet(
        request: operations.GetAgentKbsAgentsLinkKbAgentIdGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.KnowledgeBase>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetAgentKbsAgentsLinkKbAgentIdGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/agents/link/kb/{agent_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_agent_kbs_agents_link_kb__agent_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.KnowledgeBase>>()
            .json(200, z.array(components.KnowledgeBase$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Workflows
     *
     * @remarks
     * List all workflows for a user
     */
    async listWorkflowsWorkflowsGet(options?: RequestOptions): Promise<Array<components.Workflow>> {
        const path$ = this.templateURLComponent("/workflows")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_workflows_workflows_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.Workflow>>()
            .json(200, z.array(components.Workflow$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Workflow
     *
     * @remarks
     * Create a new workflow
     */
    async createWorkflowWorkflowsPost(
        request: components.WorkflowCreate,
        options?: RequestOptions
    ): Promise<components.Workflow> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.WorkflowCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/workflows")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_workflow_workflows_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.Workflow>()
            .json(200, components.Workflow$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Workflow
     *
     * @remarks
     * Get a workflow
     */
    async getWorkflowWorkflowsWorkflowIdGet(
        request: operations.GetWorkflowWorkflowsWorkflowIdGetRequest,
        options?: RequestOptions
    ): Promise<components.Workflow> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetWorkflowWorkflowsWorkflowIdGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            workflow_id: encodeSimple$("workflow_id", payload$.workflow_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/workflows/{workflow_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_workflow_workflows__workflow_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.Workflow>()
            .json(200, components.Workflow$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Workflow
     *
     * @remarks
     * Delete a workflow
     */
    async deleteWorkflowWorkflowsDeleteDelete(
        request: operations.DeleteWorkflowWorkflowsDeleteDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteWorkflowWorkflowsDeleteDeleteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/workflows/delete")();

        const query$ = encodeFormQuery$({
            workflow_id: payload$.workflow_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_workflow_workflows_delete_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Link Workflow Agent
     *
     * @remarks
     * Link an agent to a workflow
     */
    async linkWorkflowAgentWorkflowsLinkAgentWorkflowIdAgentIdAgentTypePost(
        request: operations.LinkWorkflowAgentWorkflowsLinkAgentWorkflowIdAgentIdAgentTypePostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.LinkWorkflowAgentWorkflowsLinkAgentWorkflowIdAgentIdAgentTypePostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            agent_type: encodeSimple$("agent_type", payload$.agent_type, {
                explode: false,
                charEncoding: "percent",
            }),
            workflow_id: encodeSimple$("workflow_id", payload$.workflow_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/workflows/link/agent/{workflow_id}/{agent_id}/{agent_type}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "link_workflow_agent_workflows_link_agent__workflow_id___agent_id___agent_type__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Unlink Workflow Agent
     *
     * @remarks
     * Unlink an agent from a workflow
     */
    async unlinkWorkflowAgentWorkflowsLinkAgentWorkflowIdAgentIdAgentTypeDelete(
        request: operations.UnlinkWorkflowAgentWorkflowsLinkAgentWorkflowIdAgentIdAgentTypeDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.UnlinkWorkflowAgentWorkflowsLinkAgentWorkflowIdAgentIdAgentTypeDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_id: encodeSimple$("agent_id", payload$.agent_id, {
                explode: false,
                charEncoding: "percent",
            }),
            agent_type: encodeSimple$("agent_type", payload$.agent_type, {
                explode: false,
                charEncoding: "percent",
            }),
            workflow_id: encodeSimple$("workflow_id", payload$.workflow_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/workflows/link/agent/{workflow_id}/{agent_id}/{agent_type}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "unlink_workflow_agent_workflows_link_agent__workflow_id___agent_id___agent_type__delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Linked Workflow Agents
     *
     * @remarks
     * Get all agents linked to a workflow
     */
    async getLinkedWorkflowAgentsWorkflowsLinkAgentWorkflowIdAgentTypeGet(
        request: operations.GetLinkedWorkflowAgentsWorkflowsLinkAgentWorkflowIdAgentTypeGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.Agent>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.GetLinkedWorkflowAgentsWorkflowsLinkAgentWorkflowIdAgentTypeGetRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            agent_type: encodeSimple$("agent_type", payload$.agent_type, {
                explode: false,
                charEncoding: "percent",
            }),
            workflow_id: encodeSimple$("workflow_id", payload$.workflow_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/workflows/link/agent/{workflow_id}/{agent_type}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "get_linked_workflow_agents_workflows_link_agent__workflow_id___agent_type__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.Agent>>()
            .json(200, z.array(components.Agent$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Sessions
     *
     * @remarks
     * List all sessions for a user
     */
    async listSessionsSessionsGet(options?: RequestOptions): Promise<Array<components.Session>> {
        const path$ = this.templateURLComponent("/sessions")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_sessions_sessions_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.Session>>()
            .json(200, z.array(components.Session$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Session
     *
     * @remarks
     * Create a new session
     */
    async createSessionSessionsPost(
        request: components.SessionCreate,
        options?: RequestOptions
    ): Promise<components.Session> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.SessionCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/sessions")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_session_sessions_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.Session>()
            .json(200, components.Session$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Session
     *
     * @remarks
     * Delete a session
     */
    async deleteSessionSessionsDeleteDelete(
        request: operations.DeleteSessionSessionsDeleteDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteSessionSessionsDeleteDeleteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/sessions/delete")();

        const query$ = encodeFormQuery$({
            session_id: payload$.session_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_session_sessions_delete_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Messages
     *
     * @remarks
     * List all messages for a use session
     */
    async listMessagesSessionsSessionIdMessagesGet(
        request: operations.ListMessagesSessionsSessionIdMessagesGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.Message>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.ListMessagesSessionsSessionIdMessagesGetRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            session_id: encodeSimple$("session_id", payload$.session_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/sessions/{session_id}/messages")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_messages_sessions__session_id__messages_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.Message>>()
            .json(200, z.array(components.Message$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Run Session Workflow
     *
     * @remarks
     * Runs a workflow on provided message
     */
    async runSessionWorkflowSessionsSessionIdWorkflowWorkflowIdRunPost(
        request: operations.RunSessionWorkflowSessionsSessionIdWorkflowWorkflowIdRunPostRequest,
        options?: RequestOptions
    ): Promise<components.RunWorkflowResponse> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RunSessionWorkflowSessionsSessionIdWorkflowWorkflowIdRunPostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RunWorkflowRequest, { explode: true });

        const pathParams$ = {
            session_id: encodeSimple$("session_id", payload$.session_id, {
                explode: false,
                charEncoding: "percent",
            }),
            workflow_id: encodeSimple$("workflow_id", payload$.workflow_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/sessions/{session_id}/workflow/{workflow_id}/run"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID:
                "run_session_workflow_sessions__session_id__workflow__workflow_id__run_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.RunWorkflowResponse>()
            .json(200, components.RunWorkflowResponse$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Teams
     *
     * @remarks
     * List all teams for a user
     */
    async listTeamsTeamGet(options?: RequestOptions): Promise<Array<components.Team>> {
        const path$ = this.templateURLComponent("/team")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_teams_team_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<components.Team>>()
            .json(200, z.array(components.Team$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * Create Team
     *
     * @remarks
     * Create a new team
     */
    async createTeamTeamPost(
        request: components.TeamCreate,
        options?: RequestOptions
    ): Promise<components.Team> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => components.TeamCreate$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/team")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_team_team_post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<components.Team>()
            .json(200, components.Team$inboundSchema)
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Team
     *
     * @remarks
     * Delete a team
     */
    async deleteTeamTeamDelete(
        request: operations.DeleteTeamTeamDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeleteTeamTeamDeleteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/team")();

        const query$ = encodeFormQuery$({
            team_id: payload$.team_id,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_team_team_delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List Team Members
     *
     * @remarks
     * List all members of a team
     */
    async listTeamMembersTeamMemberTeamIdGet(
        request: operations.ListTeamMembersTeamMemberTeamIdGetRequest,
        options?: RequestOptions
    ): Promise<Array<components.TeamMember>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.ListTeamMembersTeamMemberTeamIdGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            team_id: encodeSimple$("team_id", payload$.team_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/team_member/{team_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "list_team_members_team_member__team_id__get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<Array<components.TeamMember>>()
            .json(200, z.array(components.TeamMember$inboundSchema))
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Create Team Member
     *
     * @remarks
     * Create a new team member
     */
    async createTeamMemberTeamMemberTeamIdMemberIdPost(
        request: operations.CreateTeamMemberTeamMemberTeamIdMemberIdPostRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.CreateTeamMemberTeamMemberTeamIdMemberIdPostRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            member_id: encodeSimple$("member_id", payload$.member_id, {
                explode: false,
                charEncoding: "percent",
            }),
            team_id: encodeSimple$("team_id", payload$.team_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/team_member/{team_id}/{member_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "create_team_member_team_member__team_id___member_id__post",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Team Member
     *
     * @remarks
     * Delete a team member
     */
    async deleteTeamMemberTeamMemberTeamIdMemberIdDelete(
        request: operations.DeleteTeamMemberTeamMemberTeamIdMemberIdDeleteRequest,
        options?: RequestOptions
    ): Promise<any> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeleteTeamMemberTeamMemberTeamIdMemberIdDeleteRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            member_id: encodeSimple$("member_id", payload$.member_id, {
                explode: false,
                charEncoding: "percent",
            }),
            team_id: encodeSimple$("team_id", payload$.team_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/team_member/{team_id}/{member_id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "delete_team_member_team_member__team_id___member_id__delete",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["422", "4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .json(422, errors.HTTPValidationError$inboundSchema, { err: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Version
     */
    async getVersionVersionGet(options?: RequestOptions): Promise<any> {
        const path$ = this.templateURLComponent("/version")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        let security$;
        if (typeof this.options$.oAuth2PasswordBearer === "function") {
            security$ = { oAuth2PasswordBearer: await this.options$.oAuth2PasswordBearer() };
        } else if (this.options$.oAuth2PasswordBearer) {
            security$ = { oAuth2PasswordBearer: this.options$.oAuth2PasswordBearer };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "get_version_version_get",
            oAuth2Scopes: [],
            securitySource: this.options$.oAuth2PasswordBearer,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<any>()
            .json(200, z.any())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }
}
